[{"name":"app.R","content":"library(shiny)\nlibrary(bslib)\n\nsource(\"model_utils.R\")\n\n# Custom Theme\nmy_theme <- bs_theme(\n  version = 5,\n  bootswatch = \"zephyr\",\n  primary = \"#007bff\",\n  secondary = \"#6c757d\",\n  success = \"#28a745\"\n  # base_font = font_google(\"Inter\"),\n  # heading_font = font_google(\"Outfit\")\n)\n\nui <- page_sidebar(\n  theme = my_theme,\n  title = \"Serverless SIR Model (PWA)\",\n  sidebar = sidebar(\n    title = \"Parameters\",\n    width = 350,\n    numericInput(\"N\", \"Population Size (N)\", value = 100000, min = 1000, step = 1000),\n    sliderInput(\"beta\", \"Transmission Rate (beta)\", min = 0, max = 2, value = 0.4, step = 0.01),\n    sliderInput(\"recov\", \"Recovery Duration (days)\", min = 1, max = 30, value = 10, step = 0.5),\n    numericInput(\"I\", \"Initial Infected (I)\", value = 1, min = 1),\n    sliderInput(\"VE\", \"Vaccine Efficacy (VE)\", min = 0, max = 1, value = 0.95, step = 0.01),\n    sliderInput(\"NIlimit\", \"Non-Inferiority Limit\", min = 0, max = 0.5, value = 0.1, step = 0.01),\n    sliderInput(\"cov\", \"Daily Vac. Coverage (%)\", min = 0, max = 5, value = 1, step = 0.1, post = \"%\"),\n    numericInput(\"vac_start\", \"Vaccination Start Day\", value = 1, min = 0),\n    numericInput(\"time_end\", \"Model Duration (days)\", value = 300, min = 30),\n    radioButtons(\"model_type\", \"Model Type\",\n                 choices = list(\"Model B - Law Paper\" = 1, \"Conventional SIR\" = 0),\n                 selected = 1),\n    hr(),\n    actionButton(\"run\", \"Run Model\", class = \"btn-primary w-100\")\n  ),\n  \n  navset_card_underline(\n    nav_panel(\"Plots\",\n              layout_columns(\n                card(\n                  card_header(\"Scenario 1: Actual VE\"),\n                  plotOutput(\"plot_actual\", height = \"400px\")\n                ),\n                card(\n                  card_header(\"Scenario 2: At VE - NI Limit\"),\n                  plotOutput(\"plot_ni\", height = \"400px\")\n                )\n              )\n    ),\n    nav_panel(\"Tables\",\n              layout_columns(\n                card(\n                  card_header(\"Model Comparison\"),\n                  tableOutput(\"table_comparison\")\n                ),\n                card(\n                  card_header(\"Input Parameters\"),\n                  tableOutput(\"table_inputs\")\n                )\n              )\n    ),\n    nav_panel(\"About\",\n              markdown(\n                \"## SIR Model with Vaccination\n                \n                This application runs entirely in your browser using WebAssembly.\n                \n                **Model Details:**\n                *   N: Population size\n                *   beta: Transmission rate\n                *   recov: Recovery duration\n                *   Uses a pure R Ordinary Differential Equations (ODE) solver.\n                \"\n              )\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n  \n  # Reactive Trigger\n  model_results <- eventReactive(input$run, {\n    # Convert coverage % to decimal\n    cov_decimal <- input$cov / 100\n    \n    run_sir_model(\n      beta = input$beta,\n      recov = input$recov,\n      N = input$N,\n      I = input$I,\n      VE = input$VE,\n      NIlimit = input$NIlimit,\n      cov = cov_decimal,\n      vac_start = input$vac_start,\n      time_end = input$time_end,\n      model_type = as.numeric(input$model_type)\n    )\n  }, ignoreNULL = FALSE) # Run once on startup\n  \n  output$plot_actual <- renderPlot({\n    res <- model_results()\n    if (res$status == \"error\") {\n      plot(1, type = \"n\", axes = FALSE, xlab = \"\", ylab = \"\")\n      text(1, 1, res$message, col = \"red\", cex = 1.2)\n      return()\n    }\n    \n    df <- res$data_actual\n    params <- res$params\n    \n    # Custom Plotting Logic mimicking original style\n    matplot(df$time, cbind(df$S, df$I, df$R, df$Total_inf),\n            type = \"l\", lty = 1, lwd = 2, col = c(\"blue\", \"red\", \"green\", \"black\"),\n            xlab = \"Time (days)\", ylab = \"Proportion (%)\", ylim = c(0, 100),\n            main = paste0(\"Actual VE, R0=\", sprintf(\"%05.2f\", params$R0))\n    )\n    grid()\n    legend(\"topright\", legend = c(\"Susceptible\", \"Infected\", \"Immune/Vac\", \"Total Inf\"),\n           col = c(\"blue\", \"red\", \"green\", \"black\"), lty = 1, lwd = 2, bty = \"n\")\n    \n    # Add HIT lines\n    abline(h = 100 * (1 / params$VE) * (1 - 1 / (params$beta / (1 / params$recov))), col = \"cyan\", lwd = 2, lty = 2)\n    abline(v = params$hday, col = \"cyan\", lwd = 2, lty = 2)\n  })\n  \n  output$plot_ni <- renderPlot({\n    res <- model_results()\n    if (res$status == \"error\") return()\n    \n    df <- res$data_ni\n    params <- res$params\n    \n    matplot(df$time, cbind(df$S, df$I, df$R, df$Total_inf),\n            type = \"l\", lty = 1, lwd = 2, col = c(\"blue\", \"red\", \"green\", \"black\"),\n            xlab = \"Time (days)\", ylab = \"Proportion (%)\", ylim = c(0, 100),\n            main = paste0(\"At VE - NI Limit (\", 100 * params$NIlimit, \"%)\")\n    )\n    grid()\n    \n    # Add HIT lines\n    abline(h = 100 * (1 / (params$VE - params$NIlimit)) * (1 - 1 / (params$beta / (1 / params$recov))), col = \"cyan\", lwd = 2, lty = 2)\n    abline(v = params$hday_ni, col = \"cyan\", lwd = 2, lty = 2)\n  })\n  \n  output$table_comparison <- renderTable({\n    res <- model_results()\n    if (res$status == \"error\") return(NULL)\n    res$comparison_table\n  }, striped = TRUE, hover = TRUE, bordered = TRUE)\n  \n  output$table_inputs <- renderTable({\n    res <- model_results()\n    if (res$status == \"error\") return(NULL)\n    res$input_table\n  }, striped = TRUE, hover = TRUE, bordered = TRUE)\n}\n\nshinyApp(ui, server)\n","type":"text"},{"name":"model_utils.R","content":"\n# Pure R ODE Solver (Runge-Kutta 4th Order)\nsolve_ode <- function(y, times, func, parms, ...) {\n  # Time step\n  dt <- times[2] - times[1] \n  # If step is too large, we might want to subdivide, but for this refactor we will trust the input time grid\n  # or implement a simple fixed step substep. Let's do fixed substeps for stability.\n  \n  steps_per_unit <- 10 # 10 steps per day\n  h <- dt / steps_per_unit\n  \n  # Initialize output matrix\n  n_vars <- length(y)\n  n_times <- length(times)\n  out <- matrix(NA, nrow = n_times, ncol = n_vars + 1)\n  colnames(out) <- c(\"time\", names(y))\n  \n  current_y <- y\n  current_t <- times[1]\n  \n  out[1, ] <- c(current_t, current_y)\n  \n  for (i in 2:n_times) {\n    target_t <- times[i]\n    while (current_t < target_t - h/2) { # Robust comparison\n      \n      # RK4 step\n      k1 <- func(current_t, current_y, parms)[[1]]\n      k2 <- func(current_t + h/2, current_y + h/2 * k1, parms)[[1]]\n      k3 <- func(current_t + h/2, current_y + h/2 * k2, parms)[[1]]\n      k4 <- func(current_t + h, current_y + h * k3, parms)[[1]]\n      \n      current_y <- current_y + (h/6) * (k1 + 2*k2 + 2*k3 + k4)\n      current_t <- current_t + h\n    }\n    # Save result (approximate at target_t)\n    out[i, ] <- c(target_t, current_y)\n  }\n  \n  return(as.data.frame(out))\n}\n\n# Define the ODE functions globally\nvm_B2_hit <- function(time, state, parameters) {\n  with(as.list(c(state, parameters)), {\n    N <- S + I + R\n    F_B <- beta * (I / N)\n    if (modely == 1) {\n      F_B <- beta * (I / N) * ((N - R) / N)\n    }\n    if (time >= vac_start) {\n      rate <- p * (ve - NIlimit)\n    } else {\n      rate <- 0\n    }\n    # Ensure S, I, R don't go negative which can happen in discrete steps\n    # But for RK4 with small steps it should be fine.\n    \n    dS <- -F_B * S - min(S, N * rate)\n    dI <- F_B * S - sigma * I\n    dR <- sigma * I + min(S, N * rate)\n    dTotal_inf <- F_B * S\n    dTotal_vac <- min(S, N * p) \n    \n    return(list(c(dS, dI, dR, dTotal_inf, dTotal_vac)))\n  })\n}\n\nvm_B2 <- function(time, state, parameters) {\n  with(as.list(c(state, parameters)), {\n    N <- S + I + R\n    F_B <- beta * (I / N)\n    if (modely == 1) {\n      F_B <- beta * (I / N) * ((N - R) / N)\n    }\n    if (time >= vac_start & time <= hit) {\n      ve_curr <- ve - NIlimit\n      cov <- p\n    } else {\n      ve_curr <- 0\n      cov <- 0\n    }\n    rate <- p * ve_curr\n    dS <- -F_B * S - min(S, N * rate)\n    dI <- F_B * S - sigma * I\n    dR <- sigma * I + min(S, N * rate)\n    dTotal_inf <- F_B * S\n    dTotal_vac <- min(S, N * cov)\n    return(list(c(dS, dI, dR, dTotal_inf, dTotal_vac)))\n  })\n}\n\nrun_sir_model <- function(beta = 0.4, recov = 10, N = 100000, I = 1,\n                          VE = 0.95, NIlimit = 0.1, cov = 0.01,\n                          vac_start = 1, time_end = 300,\n                          model_type = 1) {\n  \n  # Basic Assignments\n  R_init <- cov * N\n  tv <- cov * N\n  Initial_values <- c(S = N - I - R_init, I = I, R = R_init, Total_inf = I, Total_vac = tv)\n  parameters <- c(beta = beta, sigma = 1 / recov, ve = VE, p = cov, b = 0, vac_start = vac_start, NIlimit = 0, modely = model_type)\n  time1 <- seq(from = 1, to = time_end, by = 1)\n  \n  # Prepare input values table dataframe\n  inputvalues <- data.frame(\n    Variable = c(\"Population\", \"start I\", \"transmission rate\", \"recovery\", \"% daily coverage\",\n                 \"Vaccine efficacy\", \"NI limit\", \"Vaccination start\", \"Model duration\", \"Model type\"),\n    Value = c(format(N, big.mark = \",\", scientific = FALSE),\n              I,\n              round(beta, 2),\n              paste0(round(recov, 2), \" days\"),\n              paste0(round(100 * cov, 2), \"%\"),\n              paste0(100 * VE, \"%\"),\n              paste0(100 * NIlimit, \"%\"),\n              paste0(round(vac_start, 2), \" days\"),\n              paste0(time_end, \" days\"),\n              ifelse(model_type == 1, \"Model B - Law paper\", \"Conventional SIR\"))\n  )\n  \n  # First ODE Run: Find Herd Immunity Threshold (HIT) day\n  # We run with the base parameters first\n  VM_model_B_hit <- solve_ode(y = Initial_values, func = vm_B2_hit, parms = parameters, times = time1)\n  \n  # Normalize to Percentage\n  # Note: solve_ode returns data.frame with 'time' as col 1 and vars following.\n  # We need to ensure calculations use correct columns.\n  VM_model_B_hit_pct <- VM_model_B_hit\n  VM_model_B_hit_pct[, -1] <- 100 * VM_model_B_hit[, -1] / N\n  \n  # Calculate HIT day\n  # Formula: 100 * (1/VE) * (1 - 1/R0)\n  R0 <- beta * recov\n  target_R <- 100 * (1 / VE) * (1 - 1 / (beta / (1 / recov)))\n  \n  hday <- tryCatch({\n    round(approx(VM_model_B_hit_pct$R, VM_model_B_hit_pct$time, target_R)$y)\n  }, error = function(e) NA)\n  \n  if (is.na(hday)) hday <- 999\n  \n  # Second ODE Run: Actual Model\n  results_actual <- NULL\n  if (vac_start < hday) {\n    parameters_run2 <- c(parameters, hit = hday)\n    VM_model_B <- solve_ode(y = Initial_values, func = vm_B2, parms = parameters_run2, times = time1)\n    \n    # Calculate stats\n    tot_inf_n <- round(rev(VM_model_B$Total_inf)[1])\n    tot_inf_p <- round(100 * tot_inf_n / N, 1)\n    tot_treats_n <- round(rev(VM_model_B$Total_vac)[1])\n    tot_treats_p <- round(100 * tot_treats_n / N, 1)\n    \n    results_actual <- list(\n      df = VM_model_B, # Raw numbers\n      hi_day = hday,\n      stats = c(hday, format(tot_inf_n, big.mark=\",\"), tot_inf_p, format(tot_treats_n, big.mark=\",\"), tot_treats_p)\n    )\n  }\n  \n  # Third ODE Run: NI Limit\n  parameters_ni <- parameters\n  parameters_ni[\"NIlimit\"] <- NIlimit\n  \n  # Recalculate HIT for NI\n  VM_model_B_NI_hit <- solve_ode(y = Initial_values, func = vm_B2_hit, parms = parameters_ni, times = time1)\n  \n  VM_model_B_NI_hit_pct <- VM_model_B_NI_hit\n  VM_model_B_NI_hit_pct[, -1] <- 100 * VM_model_B_NI_hit[, -1] / N\n  \n  target_R_ni <- 100 * (1 / (VE - NIlimit)) * (1 - 1 / R0)\n  hday_ni <- tryCatch({\n    round(approx(VM_model_B_NI_hit_pct$R, VM_model_B_NI_hit_pct$time, target_R_ni)$y)\n  }, error = function(e) NA)\n  \n  if (is.na(hday_ni)) hday_ni <- 999\n  \n  # Final Run for NI\n  parameters_ni_run2 <- c(parameters_ni, hit = hday_ni)\n  VM_model_B_NI <- solve_ode(y = Initial_values, func = vm_B2, parms = parameters_ni_run2, times = time1)\n  \n  tot_inf_n_ni <- round(rev(VM_model_B_NI$Total_inf)[1])\n  tot_inf_p_ni <- round(100 * tot_inf_n_ni / N, 1)\n  tot_treats_n_ni <- round(rev(VM_model_B_NI$Total_vac)[1])\n  tot_treats_p_ni <- round(100 * tot_treats_n_ni / N, 1)\n  \n  results_ni <- list(\n    df = VM_model_B_NI,\n    hi_day = hday_ni,\n    stats = c(hday_ni, format(tot_inf_n_ni, big.mark=\",\"), tot_inf_p_ni, format(tot_treats_n_ni, big.mark=\",\"), tot_treats_p_ni)\n  )\n  \n  # Combine Comparison Table\n  # Stats vector order: HI day, Num infected, per pop inf, Num treated, per pop trt\n  \n  # Handle the case where Actual run didn't happen (vac_start >= hday)\n  if (is.null(results_actual)) {\n    # If invalid, we just make filler data or return warning\n    return(list(status = \"error\", message = paste0(\"Vaccination start day (\", vac_start, \") is on or after herd immunity day (\", hday, \").\")))\n  }\n  \n  comparison_df <- data.frame(\n    Model = c(\"Actual VE\", \"At VE-NI limit\"),\n    `HI day` = c(ifelse(results_actual$hi_day == 999, paste0(\">\", time_end), results_actual$hi_day),\n                 ifelse(results_ni$hi_day == 999, paste0(\">\", time_end), results_ni$hi_day)),\n    `Num infected` = c(results_actual$stats[2], results_ni$stats[2]),\n    `% pop inf` = c(results_actual$stats[3], results_ni$stats[3]),\n    `Num treated` = c(results_actual$stats[4], results_ni$stats[4]),\n    `% pop trt` = c(results_actual$stats[5], results_ni$stats[5]),\n    check.names = FALSE\n  )\n  \n  return(list(\n    status = \"success\",\n    input_table = inputvalues,\n    comparison_table = comparison_df,\n    data_actual = results_actual$df,\n    data_ni = results_ni$df,\n    params = list(beta = beta, recov = recov, VE = VE, NIlimit = NIlimit, hday = hday, hday_ni = hday_ni, R0 = R0)\n  ))\n}\n","type":"text"}]
