<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Shiny App</title>

  <link rel="manifest" href="/sir-model-pwa/manifest.json">

  <script type="module">
    import { runExportedApp } from "/sir-model-pwa/shinylive/shinylive.js";
    runExportedApp({
      id: "root",
      appEngine: "r",
      appJsonPath: "/sir-model-pwa/app.json",
      relPath: "/sir-model-pwa/",
    });
  </script>

  <link rel="stylesheet" href="/sir-model-pwa/shinylive/style-resets.css" />
  <link rel="stylesheet" href="/sir-model-pwa/shinylive/shinylive.css" />

  <style>
    #pwa-status {
      position: fixed;
      right: 10px;
      bottom: 10px;
      z-index: 9999;
      font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      padding: 6px 8px;
      border-radius: 10px;
      background: rgba(0,0,0,0.70);
      color: #fff;
      backdrop-filter: blur(6px);
      max-width: 70vw;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
</head>

<body>
  <div style="height: 100vh; width: 100vw" id="root"></div>
  <div id="pwa-status" aria-live="polite"></div>

<script>
(function () {
  const el = document.getElementById("pwa-status");
  const SCOPE = "/sir-model-pwa/";
  const SW_URL = "/sir-model-pwa/shinylive-sw.js";
  const VERSION_URL = "/sir-model-pwa/version.json";

  const LS_REL = "sir_release_version_last";
  let releaseV = (localStorage.getItem(LS_REL) || "").trim();
  let runtimeV = ""; // from SW when controlled

  function render(note) {
    const online = navigator.onLine ? "online" : "OFFLINE";
    const cached = navigator.serviceWorker?.controller ? "cached" : "live";
    const v = runtimeV || releaseV || "…";
    el.textContent = `v ${v} · ${online} · ${cached}${note ? " · " + note : ""}`;
  }

  function parseV(v) {
    // supports "v6", "6", "v6.1"
    const m = String(v || "").match(/(\d+(\.\d+)?)/);
    return m ? Number(m[1]) : NaN;
  }

  function requestRuntimeVersion() {
    return new Promise((resolve) => {
      if (!navigator.serviceWorker?.controller) return resolve(null);

      const ch = new MessageChannel();
      const t = setTimeout(() => resolve(null), 600);

      ch.port1.onmessage = (e) => {
        clearTimeout(t);
        resolve(e?.data?.type === "VERSION" ? e.data.version : null);
      };

      navigator.serviceWorker.controller.postMessage({ type: "GET_VERSION" }, [ch.port2]);
    });
  }

  async function fetchReleaseVersionFresh() {
    // Online: cache-bust to avoid GH Pages / SW cached version.json
    // Offline: don't fetch; keep last-known
    if (!navigator.onLine) return releaseV || null;

    try {
      const r = await fetch(`${VERSION_URL}?cb=${Date.now()}`, { cache: "no-store" });
      if (!r.ok) return releaseV || null;
      const j = await r.json();
      const v = (j?.version || "").trim();
      if (v) {
        releaseV = v;
        localStorage.setItem(LS_REL, v);
      }
      return v || null;
    } catch {
      return releaseV || null;
    }
  }

  async function registerSW() {
    if (!("serviceWorker" in navigator)) return null;

    // updateViaCache:"none" reduces “stuck on old SW script”
    return await navigator.serviceWorker.register(SW_URL, {
      scope: SCOPE,
      updateViaCache: "none"
    });
  }

  async function robustUpdateCheck() {
    // No update attempts offline
    if (!navigator.onLine) return;

    const reg = await navigator.serviceWorker.getRegistration(SCOPE);
    if (!reg) return;

    // Force the browser to check for a newer SW now
    try { await reg.update(); } catch (_) {}

    // If a new SW is waiting, activate it and reload once
    if (reg.waiting) {
      render("updating…");

      const KEY = "sir_reload_once";
      navigator.serviceWorker.addEventListener("controllerchange", () => {
        if (sessionStorage.getItem(KEY) === "1") return;
        sessionStorage.setItem(KEY, "1");
        window.location.reload();
      });

      reg.waiting.postMessage({ type: "SKIP_WAITING" });
    }
  }

  async function refreshAll() {
    render();

    // Register SW (safe; does not touch install logic)
    await registerSW();

    // Update display from release.json (fresh when online)
    await fetchReleaseVersionFresh();
    render();

    // Runtime version (truth) if controlled
    runtimeV = (await requestRuntimeVersion()) || runtimeV;
    render();

    // If release is newer than runtime, push the update flow
    const rNum = parseV(releaseV);
    const tNum = parseV(runtimeV);
    if (isFinite(rNum) && isFinite(tNum) && rNum > tNum) {
      await robustUpdateCheck();
    } else {
      // still do a lightweight update check sometimes when online
      await robustUpdateCheck();
    }
  }

  window.addEventListener("online", refreshAll);
  window.addEventListener("offline", () => render());

  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.addEventListener("controllerchange", async () => {
      // After reload, controllerchange may fire; just refresh label
      runtimeV = (await requestRuntimeVersion()) || runtimeV;
      render();
    });
  }

  render();
  refreshAll();
})();
</script>

</body>
</html>
